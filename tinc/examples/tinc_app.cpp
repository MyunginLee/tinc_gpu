#include "tinc/DataPoolJson.hpp"
#include "tinc/DiskBufferImage.hpp"
#include "tinc/DiskBufferJson.hpp"
#include "tinc/ProcessorCpp.hpp"
#include "tinc/TincServer.hpp"
#include "tinc/vis/GUI.hpp"

#include "al/app/al_App.hpp"
#include "al/graphics/al_Texture.hpp"
#include "al/ui/al_ControlGUI.hpp"

#include <fstream>

// This example uses all the elements available through the TINC server. You can
// test connection to the TINC server by using the TINC jupyter notebook in the
// tinc-python/jupyter-notebooks directory

// For details on how each individual component works, see the rest of the
// examples

// This app requires that you run the datapool.cpp example prior, as it relies
// on data generated by that example.

struct MyApp : public al::App {
  tinc::ParameterSpace ps;
  tinc::DataPoolJson dp{ps};

  tinc::ParameterSpaceDimension procParameter{"procParam", ""};
  tinc::ProcessorCpp processor;
  float computedValue{0};

  tinc::DiskBufferImage dataBuffer{"graph", "output.png"};

  tinc::TincServer tserv;

  // Graphics memebers
  al::Texture graphTex;

  void prepareParameterSpace() {

    procParameter.getParameter<al::Parameter>().min(-10.0);
    procParameter.getParameter<al::Parameter>().max(10.0);
    auto dirDim = ps.newDimension("dirDim", tinc::ParameterSpaceDimension::ID);
    uint8_t values[] = {0, 2, 4, 6, 8};
    dirDim->appendSpaceValues(values, 5, "datapool_directory_");
    dirDim->conformSpace();

    auto internalValuesDim = ps.newDimension("internalValuesDim");
    float internalValues[] = {-0.3f, -0.2f, -0.1f, 0.0f, 0.1f, 0.2f, 0.3f};
    internalValuesDim->appendSpaceValues(internalValues, 7);
    internalValuesDim->conformSpace();
    internalValuesDim->setCurrentIndex(0);

    // The running path for the parameter space is determined by 'dirDim'
    ps.setCurrentPathTemplate("%%dirDim%%");
  }

  void prepareProcessor() {

    processor.processingFunction = [&]() {
      computedValue =
          1.0 + ps.getDimension("internalValuesDim")->getCurrentValue() *
                    procParameter.getCurrentValue();

      return true;
    };
    // processor will be run whenever procParameter changes
    processor.registerDimension(procParameter);
  }

  void prepareGui() {
    al::imguiBeginFrame();
    al::ParameterGUI::beginPanel("Parameter Space");
    tinc::vis::drawControls(ps);
    al::ParameterGUI::draw(procParameter.getParameterMeta());
    ImGui::Text("Computed value: %f", computedValue);
    al::ParameterGUI::endPanel();
    al::imguiEndFrame();
  }

  // al::App callbacks

  void onCreate() override {
    // Graphics initialization
    al::imguiInit(); // Initialize GUI toolkit

    graphTex.create2D(512, 512);

    // Initialize TINC objects
    prepareParameterSpace();
    prepareProcessor();

    // Configure DataPool
    dp.registerDataFile("datapool_data.json", "internalValuesDim");

    // Configure TincServer
    // Registering the DataPool will bring in the ParameterSpace and
    // ParameterSpaceDimensions associated with it
    tserv << dp;
    // Register the image data buffer
    tserv << dataBuffer;
    tserv.setVerbose(true); // Show more information

    // Start TINC server with default parameters
    tserv.start();
  }

  void onAnimate(double dt) override {
    prepareGui();

    // Update graphics texture if the buffer has been updated
    if (dataBuffer.newDataAvailable()) {
      if (dataBuffer.get()->array().size() == 0) {
        std::cout << "failed to load image" << std::endl;
      }
      std::cout << "loaded image size: " << dataBuffer.get()->width() << ", "
                << dataBuffer.get()->height() << std::endl;

      graphTex.resize(dataBuffer.get()->width(), dataBuffer.get()->height());
      graphTex.submit(dataBuffer.get()->array().data(), GL_RGBA,
                      GL_UNSIGNED_BYTE);

      graphTex.filter(al::Texture::LINEAR);
    }
  }

  void onDraw(al::Graphics &g) override {
    g.clear(0);
    // Draw the texture
    g.pushMatrix();
    g.translate(0, 0, -4);
    g.quad(graphTex, -1, 1, 2, -1.5);
    g.popMatrix();

    // Draw the GUI control panel
    al::imguiDraw();
  }

  void onExit() override {
    tserv.stop();
    al::imguiShutdown();
  }
};

int main() {
  MyApp().start();
  return 0;
}
